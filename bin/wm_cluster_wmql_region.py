import argparse
import os
import numpy
import glob

try:
    import whitematteranalysis as wma
except:
    print "<wm_cluster_wmql_region> Error importing white matter analysis package\n"
    raise

parser = argparse.ArgumentParser(
    description="Find the WMQL regions per cluster across multiple subjects.",
    epilog="Written by Fan Zhang, fzhang@bwh.harvard.edu")

parser.add_argument("-v", "--version",
    action="version", default=argparse.SUPPRESS,
    version='1.0',
    help="Show program's version number and exit")
parser.add_argument(
    'inputDir',
    help='Contains all txt files obtained from wm_cluster_wmql_region_per_subject.py.')
parser.add_argument(
    'outputDirectory',
    help='The output directory will be created if it does not exist.')
parser.add_argument(
    'clusterLocationFile',
    help='A file showing the cluster location information, obtained using wm_assess_cluster_location.py')
parser.add_argument(
    '-column',
    dest='column', type=int, default=5,
    help='Specify which column in the location file is used. Default using the 5th (location) column, which generated by wm_assess_cluster_location.py.'
         'Users could adjust this file according to their manual decision, given there could be Not Given location.')
parser.add_argument(
    '-tract',
    dest='tract', type=str, default='all',
    help='Specify which tract to analysis, e.g. cst, af')

args = parser.parse_args()

if not os.path.exists(args.clusterLocationFile):
    print "<wm_remove_invalid_clusters> Error: Location file", args.clusterLocationFile, "does not exist."
    exit()

outdir = args.outputDirectory
if not os.path.exists(outdir):
    print "Output directory", outdir, "does not exist, creating it."
    os.makedirs(outdir)

input_mask_comm = "{0}/*commissural.txt".format(args.inputDir)
region_per_subject_comm_paths = glob.glob(input_mask_comm)

input_mask_left = "{0}/*left.txt".format(args.inputDir)
region_per_subject_left_paths = glob.glob(input_mask_left)

input_mask_right = "{0}/*right.txt".format(args.inputDir)
region_per_subject_right_paths = glob.glob(input_mask_right)

num_subjects = len(region_per_subject_comm_paths)

target_tracts = [1]
target_tracts += range(3,10) # cc
target_tracts += range(45,87) # others

region_per_subject_comm_list = []
region_per_subject_left_list = []
region_per_subject_right_list = []
for comm_file, left_file, right_file in zip(region_per_subject_comm_paths, region_per_subject_left_paths, region_per_subject_right_paths):
    #print '<wm_cluster_wmql_region> Loading', comm_file.replace('_commissural.txt', '*')
    comm = numpy.genfromtxt(comm_file, delimiter='\t', dtype="|S")
    left = numpy.genfromtxt(left_file, delimiter='\t', dtype="|S")
    right = numpy.genfromtxt(right_file, delimiter='\t', dtype="|S")

    comm = comm[:, target_tracts]
    left = left[:, target_tracts]
    right = right[:, target_tracts]

    region_per_subject_comm_list.append(comm)
    region_per_subject_left_list.append(left)
    region_per_subject_right_list.append(right)

region_list = comm[0, :] # region list includes the first total number of fibers
num_regions = len(region_list)

comm_cluster_list = comm[1:, 0]
hemi_cluster_list = left[1:, 0]

num_clusters_comm = len(comm_cluster_list)
num_clusters_hemi = len(hemi_cluster_list)

num_clusters = num_clusters_comm #+ num_clusters_hemi

print 'Number of clusters:', num_clusters
print 'Number of regions:', num_regions
print 'Number of subjects:', num_subjects
print 'Region list', region_list

location_csv = numpy.genfromtxt(args.clusterLocationFile, delimiter='\t', dtype="|S")

if num_clusters != location_csv.shape[0]-1:
    print "<wm_remove_invalid_clusters> Error: number of clusters in the location file is not equal to the vtk file number in the input folder. "
    exit()

location_per_cluster = location_csv[1:, args.column-1]
#
# matrix_comm_per_region_per_cluster_per_subject = numpy.zeros((num_clusters, num_regions+1, num_subjects))
# matrix_left_per_region_per_cluster_per_subject = numpy.zeros((num_clusters, num_regions+1, num_subjects))
# matrix_right_per_region_per_cluster_per_subject = numpy.zeros((num_clusters, num_regions+1, num_subjects))
# for s_idx in range(num_subjects):
#     matrix_comm_per_region_per_cluster_per_subject[:, :, s_idx] = region_per_subject_comm_list[s_idx][1:, 1:]
#     matrix_left_per_region_per_cluster_per_subject[:, :, s_idx] = region_per_subject_left_list[s_idx][1:, 1:]
#     matrix_right_per_region_per_cluster_per_subject[:, :, s_idx] = region_per_subject_right_list[s_idx][1:, 1:]

ROI_indices = []
for r_idx in range(num_regions):
    region = region_list[r_idx]

    if args.tract.find('cc') >= 0:
        tract = args.tract
    else:
        tract = args.tract + '.'

    if region.find(tract) >= 0:
        ROI_indices.append(r_idx)
print 'Tracts of interest:', args.tract, ROI_indices,  len(ROI_indices)
# #
# matrix_comm_per_cluster_per_subject_ROI = matrix_comm_per_region_per_cluster_per_subject[:, ROI_indices , :]
# matrix_left_per_cluster_per_subject_ROI = matrix_left_per_region_per_cluster_per_subject[:, ROI_indices , :]
# matrix_right_per_cluster_per_subject_ROI = matrix_right_per_region_per_cluster_per_subject[:, ROI_indices , :]

# for c_idx in range(num_clusters):
#     if location_per_cluster[c_idx] == 'commissural':
#         continue
#     elif location_per_cluster[c_idx] == 'hemispheric' or location_per_cluster[c_idx] == 'Not Given':
#
# if len(ROI_indices) == 2: # this for hemispheric
#     matrix_left_per_cluster_per_subject_ROI = matrix_left_per_region_per_cluster_per_subject[:, (0, ROI_indices[0]), :]
#     matrix_right_per_cluster_per_subject_ROI = matrix_left_per_region_per_cluster_per_subject[:, (0, ROI_indices[1]), :]
#
#     matrix_tract_fiber_number = matrix_left_per_cluster_per_subject_ROI[:, 1, :]  # number of fibers per cluster (total fiber number)
#
#     matrix_all_fiber_number = matrix_left_per_cluster_per_subject_ROI[:, 0, :]  # number of fibers per tract
#     matrix_all_fiber_number[matrix_tract_fiber_number == 0] = 0
#
#     matrix_fiber_number_percentage = matrix_tract_fiber_number / matrix_all_fiber_number
#
#     num_subject_per_cluster = numpy.sum(matrix_tract_fiber_number > 0, axis=1)
#
#     print num_subject_per_cluster
#     print numpy.nansum(matrix_fiber_number_percentage, axis=1) / 10
#
#     exit()

#hemi_or_comm_list = ['hemi'] * num_clusters
# for c_comm_idx in range(num_clusters_comm):
#     c_idx = int(comm_cluster_list[c_comm_idx].replace('cluster_', '')) - 1
#     hemi_or_comm_list[c_idx] = 'comm'

def region_of_one_cluster_OLD(region_per_subject_list, c_sub_idx, num_subjects, num_regions):
    subject_region_matrix_of_one_cluster = numpy.zeros((num_subjects, num_regions))

    for s_idx in range(num_subjects):
        region_one_subject = region_per_subject_list[s_idx][c_sub_idx + 1, 1:]
        region_one_subject = [float(r) for r in region_one_subject] # convert into float

        if region_one_subject[0] == 0: # if cluster is empty
            region_idx_belong = []
        else:
            region_one_subject_percentage = numpy.divide(region_one_subject, region_one_subject[0])

            if numpy.sum(region_one_subject_percentage[1:]) == 0: # if no WMQL result
                region_idx_belong = []
            else:
                region_idx_belong = numpy.argsort(region_one_subject_percentage[1:])[-1] # select the top region the cluster belongs to

        subject_region_matrix_of_one_cluster[s_idx, region_idx_belong] = 1
    #     print 's'+str(s_idx), region_idx_belong,
    # print ''

    num_subjects_per_region = numpy.sum(subject_region_matrix_of_one_cluster, axis=0)
    result_region_index = numpy.argsort(num_subjects_per_region)[-1]

    if num_subjects_per_region[result_region_index] == 0:
        result_region_index = None

    return result_region_index

def region_of_one_cluster(region_per_subject_list, c_sub_idx, num_subjects, num_regions, th_fb=0.1, th_sub=0.5):
    subject_region_matrix_of_one_cluster = numpy.zeros((num_subjects, num_regions))
    subject_fiber_number_matrix_of_one_cluster = numpy.zeros((num_subjects, num_regions))
    subject_fiber_number_matrix_of_one_cluster.fill(numpy.nan)

    for s_idx in range(num_subjects):
        region_one_subject = region_per_subject_list[s_idx][c_sub_idx + 1, 0:]
        region_one_subject = [float(r) for r in region_one_subject] # convert into float

        region_idx_belong = None
        if region_one_subject[0] > 0: # if cluster is not empty
            region_one_subject_percentage = numpy.divide(region_one_subject, region_one_subject[0])
            if numpy.sum(region_one_subject_percentage[1:]) > 0: # if WMQL has result
                region_idx_belong = numpy.argsort(region_one_subject_percentage)[-2] # select the top region the cluster belongs to. -2 is used to exclude total fiber number
                if region_one_subject_percentage[region_idx_belong] < th_fb:
                    region_idx_belong = None

        if region_idx_belong is not None:
            subject_region_matrix_of_one_cluster[s_idx, region_idx_belong] = 1
            subject_fiber_number_matrix_of_one_cluster[s_idx, region_idx_belong] = region_one_subject_percentage[region_idx_belong]
        #print '\ns'+str(s_idx), region_idx_belong,#, region_list[region_idx_belong],

    num_subjects_per_region = numpy.sum(subject_region_matrix_of_one_cluster, axis=0)
    result_region_idx = numpy.argsort(num_subjects_per_region)[-1]
    if num_subjects_per_region[result_region_idx] / num_subjects < th_sub:
        result_region_idx = None

    mean_fiber_percentage = None
    if result_region_idx is not None:
        mean_fiber_percentage = numpy.nanmean(subject_fiber_number_matrix_of_one_cluster[:, result_region_idx])

    return result_region_idx, mean_fiber_percentage

print '\n<wm_cluster_wmql_region> Extracting WMQL regions: \n'

output_file = open(os.path.join(outdir, "WMQL_clusters_from_" + args.tract + '.txt'), 'w')
outstr = 'cluster' + '\t'+ 'left percentage' + '\t'+ 'right percentage' + '\t'+ 'comm percentage' + '\n'

result_cluster_list = []
mean_fiber_percentage_list = []
for c_idx in range(num_clusters):
    cluster_name = 'cluster_{0:05d}'.format(c_idx+1)

    if  len(ROI_indices) == 1 and location_per_cluster[c_idx] == 'commissural':
        # c_comm_idx = [i for i, s in enumerate(comm_cluster_list) if cluster_name in s][0]
        result_region_index_comm, mean_fiber_percentage_comm = region_of_one_cluster(region_per_subject_comm_list, c_idx, num_subjects, num_regions)
        if result_region_index_comm == ROI_indices[0]:
            print cluster_name, 'from', location_per_cluster[c_idx]
            if result_region_index_comm is not None:
                print "%15s %8s " % (region_list[result_region_index_comm],result_region_index_comm)
            else:
                print "%15s %8s " % (None, None)

            result_cluster_list.append(c_idx)
            mean_fiber_percentage_list.append(mean_fiber_percentage_comm)

            outstr = outstr + cluster_name + '\t' + str(0) + '\t' + str(0) + '\t' + str(mean_fiber_percentage_comm) + '\n'

    elif len(ROI_indices) == 2 and (location_per_cluster[c_idx] == 'hemispheric' or location_per_cluster[c_idx] == 'Not Given'):#) and len(ROI_indices) == 2:
        #c_hemi_idx = [i for i, s in enumerate(hemi_cluster_list) if cluster_name in s][0]

        result_region_index_left, mean_fiber_percentage_left = region_of_one_cluster(region_per_subject_left_list, c_idx, num_subjects, num_regions)
        result_region_index_righ, mean_fiber_percentage_righ = region_of_one_cluster(region_per_subject_right_list, c_idx, num_subjects, num_regions)

        if result_region_index_left == ROI_indices[0] or result_region_index_righ == ROI_indices[1]:
            print cluster_name, 'from', location_per_cluster[c_idx]

            result_cluster_list.append(c_idx)

            if result_region_index_left is not None:
                print "%15s %8s %8s " % (region_list[result_region_index_left],result_region_index_left, mean_fiber_percentage_left),
                mean_fiber_percentage_list.append(mean_fiber_percentage_left)
            else:
                print "%15s %8s %8s" % (None, None, None),

            if result_region_index_righ is not None:
                print "%15s %8s %8s" % (region_list[result_region_index_righ],result_region_index_righ, mean_fiber_percentage_righ)
                mean_fiber_percentage_list.append(mean_fiber_percentage_righ)
            else:
                print "%15s %8s %8s" % (None, None, None)

            outstr = outstr + cluster_name + '\t' + str(mean_fiber_percentage_left) + '\t' + str(mean_fiber_percentage_righ) + '\t' + str(0) + '\n'

output_file.write(outstr)
output_file.close()

print 'Mean Fiber Number Percentage:', numpy.mean(mean_fiber_percentage_list)

if len(result_cluster_list) > 0:
    outstr = ' - cluster_'
    for result_cluster in result_cluster_list:
        outstr = outstr + '{0:05d}'.format(result_cluster + 1) + ', '
    print outstr[:-2]

    mrml_filename = "WMQL_clusters_from_" + args.tract + "_n" + str(len(result_cluster_list)) + ".mrml"
    print "\n<WMQL> A mrml file to display the result cluster(s) is generated as", mrml_filename
    print '  Copy this file to a folder containing the result and load it to 3D Slicer to display the fiber clusters.'

    cluster_polydatas = []
    for c_idx in result_cluster_list:
        cluster_polydatas.append("cluster_" + str(c_idx + 1).zfill(5) + ".vtp")

    number_of_files = len(cluster_polydatas)
    step = int(100 * 255.0 / (number_of_files))
    R = numpy.array(range(0, 100 * 255 + 1, step)) / 100.0
    G = numpy.abs(range(100 * -127, 100 * 128 + 1, step)) * 2.0 / 100.0
    B = numpy.array(range(100 * 255 + 1, 0, -step)) / 100.0

    colors = list()
    idx = 0
    for pd in cluster_polydatas:
        colors.append([R[idx], G[idx], B[idx]])
        idx += 1
    colors = numpy.array(colors)

    wma.mrml.write(cluster_polydatas, colors, os.path.join(outdir, mrml_filename), ratio=1.0)