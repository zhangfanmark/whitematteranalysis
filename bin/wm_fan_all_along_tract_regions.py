
import numpy
import glob
import argparse

#-----------------
# Parse arguments
#-----------------
parser = argparse.ArgumentParser(
    description="wm_fan_all_along_tract_regions",
    epilog="Written by Fan Zhang, fzhang@bwh.harvard.edu",
    version='1.0')

parser.add_argument(
    'inputDirectory',
    help='Contains tract region txt from wm_fan_subject_tract_regions ')
parser.add_argument(
    'clusterLocationFile',
    help='A file showing the cluster location information, obtained using wm_assess_cluster_location.py')
parser.add_argument(
    'outputFile',
    help='File of output results.')
parser.add_argument(
    '-column',
    dest='column', type=int, default=6,
    help='Specify which column in the location file is used. Default using the 5th (location) column, which generated by wm_assess_cluster_location.py.'
         'Users could adjust this file according to their manual decision, given there could be Not Given location.')
parser.add_argument(
    '-th_oc', type=float, default=0.5,
    help='if a cluster connects to a region in a subject')
parser.add_argument(
    '-th_sub', type=float, default=0.09,
    help='if a cluster connects to a region across subjects')

args = parser.parse_args()

input_mask_comm = "{0}/*commissural.txt".format(args.inputDirectory)
region_per_subject_comm_paths = glob.glob(input_mask_comm)

input_mask_left = "{0}/*left.txt".format(args.inputDirectory)
region_per_subject_left_paths = glob.glob(input_mask_left)

input_mask_right = "{0}/*right.txt".format(args.inputDirectory)
region_per_subject_right_paths = glob.glob(input_mask_right)

num_subjects = len(region_per_subject_comm_paths)

region_per_subject_comm_list = []
region_per_subject_left_list = []
region_per_subject_right_list = []

for comm_file, left_file, right_file in zip(region_per_subject_comm_paths, region_per_subject_left_paths, region_per_subject_right_paths):
    #print '<wm_cluster_wmql_region> Loading', comm_file.replace('_commissural.txt', '*')
    comm = numpy.genfromtxt(comm_file, delimiter='\t', dtype="|S")
    left = numpy.genfromtxt(left_file, delimiter='\t', dtype="|S")
    right = numpy.genfromtxt(right_file, delimiter='\t', dtype="|S")

    comm = comm[1:, 1:]
    left = left[1:, 1:]
    right = right[1:, 1:]

    region_per_subject_comm_list.append(comm)
    region_per_subject_left_list.append(left)
    region_per_subject_right_list.append(right)

num_clusters = comm.shape[0] / 2

location_csv = numpy.genfromtxt(args.clusterLocationFile, delimiter='\t', dtype="|S")

if num_clusters != location_csv.shape[0]-1:
    print "<wm_remove_invalid_clusters> Error: number of clusters in the location file is not equal to the vtk file number in the input folder. "
    exit()

location_per_cluster = location_csv[1:, args.column-1]

if num_clusters != location_csv.shape[0]-1:
    print "<wm_remove_invalid_clusters> Error: number of clusters in the location file is not equal to the vtk file number in the input folder. "
    exit()

print 'num_subjects', num_subjects, 'num_clusters', num_clusters

def region_of_one_cluster(region_per_subject_list, c_sub_idx, num_subjects, th_oc=0.5, th_sub=0.9):

    region_all_subjects = []
    for s_idx in range(num_subjects):
        num_fiber_one_subject = float(region_per_subject_list[s_idx][2*c_sub_idx, 0])
        regions_one_subject = region_per_subject_list[s_idx][2*c_sub_idx, 1:]
        occurrence_one_subject = region_per_subject_list[s_idx][2*c_sub_idx + 1, 1:]

        regions_one_subject = regions_one_subject[regions_one_subject != ' '][:-2]
        occurrence_one_subject = occurrence_one_subject[occurrence_one_subject != ' '][:-2]

        if len(regions_one_subject) != len(occurrence_one_subject):
            print 'Error region number and occurrence is not the same'
            exit()

        regions_one_subject = numpy.array([float(r) for r in regions_one_subject])
        occurrence_one_subject = numpy.array([float(o) for o in occurrence_one_subject])

        regions_one_subject_above_th = regions_one_subject[numpy.divide(occurrence_one_subject, num_fiber_one_subject) > th_oc]

        region_all_subjects.append(regions_one_subject_above_th)

    region_all_subjects = numpy.concatenate(region_all_subjects).astype(int)
    region_all_subjects_unique = numpy.unique(region_all_subjects)

    occurrence_per_region = numpy.bincount(region_all_subjects)[region_all_subjects_unique]

    # find the regions that are present in over th_sub subjects
    final_index = numpy.divide(occurrence_per_region, float(num_subjects)) > th_sub

    region_all_subjects_final = region_all_subjects_unique[final_index]
    occurrence_per_region_final = occurrence_per_region[final_index]

    return (region_all_subjects_final, occurrence_per_region_final)

def output_regions(cluster_region_list, output_file, max_region_number):

    outstr = 'Cluster Idx' + '\t' + 'Location'
    for r in range(max_region_number):
        outstr += '\t' + 'Region' + str(r)
    outstr += '\n'

    for file_name, location, region_occurrence in cluster_region_list:

        substr1 = file_name + '\t' + str(location)
        tmp_c = 0
        for r_o in region_occurrence:
            substr1 += '\t' + str(r_o)
            tmp_c += 1

        for r in range(tmp_c, max_region_number):
            substr1 += '\t' + ' '

        outstr += substr1 + '\n'

    output_file = open(output_file, 'w')
    output_file.write(outstr)
    output_file.close()


cluster_region_list = []
max_region_number = 0
for c_idx in range(num_clusters):
    cluster_name = 'cluster_{0:05d}'.format(c_idx+1)

    print cluster_name,
    if  location_per_cluster[c_idx] == 'commissural':
        region_comm, occurrence_comm = region_of_one_cluster(region_per_subject_comm_list, c_idx, num_subjects, th_oc=args.th_oc, th_sub=args.th_sub)

        print 'commissural'
        print region_comm, occurrence_comm

        cluster_region_list.append((cluster_name, 'commissural', region_comm))
        cluster_region_list.append((' ', '# sub', occurrence_comm))

        max_region_number = max(len(region_comm), max_region_number)

    elif location_per_cluster[c_idx] == 'hemispheric' or location_per_cluster[c_idx] == 'Not Given':
        region_left, occurrence_left = region_of_one_cluster(region_per_subject_left_list, c_idx, num_subjects, th_oc=args.th_oc, th_sub=args.th_sub)
        region_right, occurrence_right = region_of_one_cluster(region_per_subject_right_list, c_idx, num_subjects, th_oc=args.th_oc, th_sub=args.th_sub)

        print 'hemispheric'
        print region_left, occurrence_left
        print region_right, occurrence_right

        cluster_region_list.append((cluster_name, 'left_hemisphere', region_left))
        cluster_region_list.append((' ', '# sub', occurrence_left))
        cluster_region_list.append(('', 'right_hemisphere', region_right))
        cluster_region_list.append((' ', '# sub', occurrence_right))

        max_region_number = max(len(region_left), max_region_number)
        max_region_number = max(len(region_right), max_region_number)

output_regions(cluster_region_list, args.outputFile, max_region_number)

print 'Done! Save result to:', args.outputFile